//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Rectangle.h
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Copyright (c) 2023 Adrian Maurer. All rights reserved.
// Distributed under the MIT software license (http://www.opensource.org/licenses/mit-license.php).
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#ifndef AMA_RECTANGLE_H
#define AMA_RECTANGLE_H
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <array>
#include <vector>
#include "Point.h"
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace ama {
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Rectangle<T>
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Layout
// X - 1
// |   |
// 0 - X
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
class Rectangle : public std::array<Point<T>, 2>
{
// CONSTRUCTION / DESTRUCTION / ASSIGNMENT
public:
	constexpr Rectangle() noexcept;
	constexpr Rectangle(const Point<T>&, const Point<T>&) noexcept;
	constexpr Rectangle(const T, const T, const T, const T) noexcept;

// ELEMENT FUNCTIONS
public:
	constexpr T getWidth() const noexcept {return (*this)[1].x - (*this)[0].x;}
	constexpr T getHeight() const noexcept {return (*this)[1].y - (*this)[0].y;}
	constexpr Rectangle<T>& normalize() noexcept;
	constexpr Rectangle<T>& expand(const T) noexcept;
	constexpr Rectangle<T>& expand(const Point<T>&) noexcept;
	constexpr Rectangle<T>& reduce(const T) noexcept;
	constexpr Rectangle<T>& reduce(const Point<T>&) noexcept;
};
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Rectangle<T> - CONSTRUCTION / DESTRUCTION / ASSIGNMENT
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>::Rectangle() noexcept : 
	std::array<Point<T>, 2>{{{T(0), T(0)}, {T(0), T(0)}}}
{
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>::Rectangle(const Point<T>& p1, const Point<T>& p2) noexcept : 
	std::array<Point<T>, 2>{p1, p2}
{
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>::Rectangle(const T p1x, const T p1y, const T p2x, const T p2y) noexcept : 
	std::array<Point<T>, 2>{{{p1x, p1y}, {p2x, p2y}}}
{
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Rectangle<T> - ELEMENT FUNCTIONS
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>& Rectangle<T>::normalize() noexcept
{
	Rectangle<T>& ra = *this;
	if (ra[0].x > ra[1].x) std::swap(ra[0].x, ra[1].x);
	if (ra[0].y > ra[1].y) std::swap(ra[0].y, ra[1].y);
	return *this;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>& Rectangle<T>::expand(const T v) noexcept
{
	Rectangle<T>& ra = *this;
	ra[0] -= v;
	ra[1] += v;
	return *this;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>& Rectangle<T>::expand(const Point<T>& p) noexcept
{
	Rectangle<T>& ra = *this;
	ra[0] -= p;
	ra[1] += p;
	return *this;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>& Rectangle<T>::reduce(const T v) noexcept
{
	Rectangle<T>& ra = *this;
	ra[0] += v;
	ra[1] -= v;
	return *this;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>& Rectangle<T>::reduce(const Point<T>& p) noexcept
{
	Rectangle<T>& ra = *this;
	ra[0] += p;
	ra[1] -= p;
	return *this;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Rectangle<T> - GLOBAL FUNCTIONS
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T> normalize(Rectangle<T> ra) noexcept
{
	return ra.normalize();
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T> expand(Rectangle<T> ra, const T v) noexcept
{
	return ra.expand(v);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T> expand(Rectangle<T> ra, const Point<T>& p) noexcept
{
	return ra.expand(p);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T> reduce(Rectangle<T> ra, const T v) noexcept
{
	return ra.reduce(v);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T> reduce(Rectangle<T> ra, const Point<T>& p) noexcept
{
	return ra.reduce(p);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr bool isPointInUnitRectangle(const Point<T>& p) noexcept
requires std::floating_point<T>
{
	return p.x >= T(0.0) && p.y >= T(0.0) && p.x <= T(1.0) && p.y <= T(1.0);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr bool isPointInRectangle(const Point<T>& p, const Rectangle<T>& ra) noexcept
{
	return p.x >= ra[0].x && p.y >= ra[0].y && p.x <= ra[1].x && p.y <= ra[1].y;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template<class T>
constexpr bool isLineInRectangle(const Point<T>& lp1, const Point<T>& lp2, const Rectangle<T>& ra) noexcept
requires std::floating_point<T>
{
	if (isPointInRectangle(lp1, ra) || isPointInRectangle(lp2, ra)) return true;
	if (lp1.x < ra[0].x && lp2.x < ra[0].x || lp1.x > ra[1].x && lp2.x > ra[1].x) return false;
	if (lp1.y < ra[0].y && lp2.y < ra[0].y || lp1.y > ra[1].y && lp2.y > ra[1].y) return false;
	for (int i = 0; i < 2; ++i)
	{
		if (lp1.x < ra[i].x && lp2.x >= ra[i].x || lp1.x >= ra[i].x && lp2.x < ra[i].x)
		{
			const T y = (ra[i].x - lp1.x) * (lp2.y - lp1.y) / (lp2.x - lp1.x) + lp1.y;
			if (y > ra[0].y && y < ra[1].y) return true;
		}
		if (lp1.y < ra[i].y && lp2.y >= ra[i].y || lp1.y >= ra[i].y && lp2.y < ra[i].y)
		{
			const T x = (ra[i].y - lp1.y) * (lp2.x - lp1.x) / (lp2.y - lp1.y) + lp1.x;
			if (x > ra[0].x && x < ra[1].x) return true;
		}
	}
	return false;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> calcPointToRectangle(const Point<T>& p, const Point<T>* const p_p) noexcept
requires std::floating_point<T>
{
	return p * (p_p[1] - p_p[0]) + p_p[0];
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> calcPointToRectangle(const Point<T>& p, const std::vector<Point<T>>& pv) noexcept
requires std::floating_point<T>
{
	return calcPointToRectangle(p, pv.data());
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> calcPointToRectangle(const Point<T>& p, const std::array<Point<T>, 2>& pa) noexcept
requires std::floating_point<T>
{
	return calcPointToRectangle(p, pa.data());
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline Point<T> calcPointFromRectangle(const Point<T>& p, const Point<T>* const p_p)
requires std::floating_point<T>
{
	constexpr T r = T(1.0E-8); // Range
	const Point<T> v(p_p[1] - p_p[0]); // Vector
	if (fabs(v.x) > r && fabs(v.y) > r) return (p - p_p[0]) / v;
	return std::numeric_limits<T>::quiet_NaN(); // No area case
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline Point<T> calcPointFromRectangle(const Point<T>& p, const std::vector<Point<T>>& pv)
requires std::floating_point<T>
{
	return calcPointFromRectangle(p, pv.data());
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline Point<T> calcPointFromRectangle(const Point<T>& p, const std::array<Point<T>, 2>& pa)
requires std::floating_point<T>
{
	return calcPointFromRectangle(p, pa.data());
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
} //namespace ama
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#endif // AMA_RECTANGLE_H
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
