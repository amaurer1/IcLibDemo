//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Rectangle.h
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Copyright (c) 2022 Adrian Maurer. All rights reserved.
// Distributed under the MIT software license (http://www.opensource.org/licenses/mit-license.php).
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#ifndef AMA_RECTANGLE_H
#define AMA_RECTANGLE_H
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <array>
#include <vector>
#include "Point.h"
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace ama {
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Rectangle<T>
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Layout
// X - 1
// |   |
// 0 - X
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
class Rectangle : public std::array<Point<T>, 2>
{
// CONSTRUCTION / DESTRUCTION / ASSIGNMENT
public:
	constexpr Rectangle() noexcept;
	constexpr Rectangle(const Point<T>&, const Point<T>&) noexcept;
	constexpr Rectangle(const T, const T, const T, const T) noexcept;

// ELEMENT FUNCTIONS
public:
	constexpr T getWidth() const noexcept {return (*this)[1].x - (*this)[0].x;}
	constexpr T getHeight() const noexcept {return (*this)[1].y - (*this)[0].y;}
	constexpr Rectangle<T>& normalize() noexcept;
	constexpr Rectangle<T>& expand(const T) noexcept;
	constexpr Rectangle<T>& expand(const Point<T>&) noexcept;
	constexpr Rectangle<T>& reduce(const T) noexcept;
	constexpr Rectangle<T>& reduce(const Point<T>&) noexcept;
};
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Rectangle<T> - CONSTRUCTION / DESTRUCTION / ASSIGNMENT
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>::Rectangle() noexcept : 
	std::array<Point<T>, 2>{{{T(0), T(0)}, {T(0), T(0)}}}
{
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>::Rectangle(const Point<T>& p1, const Point<T>& p2) noexcept : 
	std::array<Point<T>, 2>{p1, p2}
{
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>::Rectangle(const T p1x, const T p1y, const T p2x, const T p2y) noexcept : 
	std::array<Point<T>, 2>{{{p1x, p1y}, {p2x, p2y}}}
{
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Rectangle<T> - ELEMENT FUNCTIONS
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>& Rectangle<T>::normalize() noexcept
{
	Rectangle<T>& ra = *this;
	if (ra[0].x > ra[1].x) std::swap(ra[0].x, ra[1].x);
	if (ra[0].y > ra[1].y) std::swap(ra[0].y, ra[1].y);
	return *this;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>& Rectangle<T>::expand(const T v) noexcept
{
	Rectangle<T>& ra = *this;
	ra[0] -= v;
	ra[1] += v;
	return *this;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>& Rectangle<T>::expand(const Point<T>& p) noexcept
{
	Rectangle<T>& ra = *this;
	ra[0] -= p;
	ra[1] += p;
	return *this;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>& Rectangle<T>::reduce(const T v) noexcept
{
	Rectangle<T>& ra = *this;
	ra[0] += v;
	ra[1] -= v;
	return *this;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T>& Rectangle<T>::reduce(const Point<T>& p) noexcept
{
	Rectangle<T>& ra = *this;
	ra[0] += p;
	ra[1] -= p;
	return *this;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Rectangle<T> - GLOBAL FUNCTIONS
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T> normalize(Rectangle<T> ra) noexcept
{
	return ra.normalize();
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T> expand(Rectangle<T> ra, const T v) noexcept
{
	return ra.expand(v);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T> expand(Rectangle<T> ra, const Point<T>& p) noexcept
{
	return ra.expand(p);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T> reduce(Rectangle<T> ra, const T v) noexcept
{
	return ra.reduce(v);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Rectangle<T> reduce(Rectangle<T> ra, const Point<T>& p) noexcept
{
	return ra.reduce(p);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr bool isPointInUnitRectangle(const Point<T>& p) noexcept
requires std::floating_point<T>
{
	return p.x >= T(0.0) && p.y >= T(0.0) && p.x <= T(1.0) && p.y <= T(1.0);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr bool isPointInRectangle(const Point<T>& p, const Rectangle<T>& ra) noexcept
{
	return p.x >= ra[0].x && p.y >= ra[0].y && p.x <= ra[1].x && p.y <= ra[1].y;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template<class T>
constexpr bool isLineInRectangle(const Point<T>& p1, const Point<T>& p2, const Rectangle<T>& ra) noexcept
requires std::floating_point<T>
{
	if (isPointInRectangle(p1, ra) || isPointInRectangle(p2, ra)) return true;
	if (p1.x < ra[0].x && p2.x < ra[0].x || p1.x > ra[1].x && p2.x > ra[1].x) return false;
	if (p1.y < ra[0].y && p2.y < ra[0].y || p1.y > ra[1].y && p2.y > ra[1].y) return false;
	const Rectangle<T> vra(ra[0] - p1, ra[1] - p1);
	const Point<T> vp(p2 - p1);
	if (
		vp.y >= T(0.0) && vra[0].y >= T(0.0) && vra[0].y < vp.y || 
		vp.y <= T(0.0) && vra[0].y <= T(0.0) && vra[0].y > vp.y)
	{
		if (const T s = vp.x * vra[0].y / vp.y; s > vra[0].x && s < vra[1].x) return true;
	}
	if (
		vp.y >= T(0.0) && vra[1].y >= T(0.0) && vra[1].y < vp.y || 
		vp.y <= T(0.0) && vra[1].y <= T(0.0) && vra[1].y > vp.y)
	{
		if (const T s = vp.x * vra[1].y / vp.y; s > vra[0].x && s < vra[1].x) return true;
	}
	if (
		vp.x >= T(0.0) && vra[0].x >= T(0.0) && vra[0].x < vp.x || 
		vp.x <= T(0.0) && vra[0].x <= T(0.0) && vra[0].x > vp.x)
	{
		if (const T s = vp.y * vra[0].x / vp.x; s > vra[0].y && s < vra[1].y) return true;
	}
	if (
		vp.x >= T(0.0) && vra[1].x >= T(0.0) && vra[1].x < vp.x || 
		vp.x <= T(0.0) && vra[1].x <= T(0.0) && vra[1].x > vp.x)
	{
		if (const T s = vp.y * vra[1].x / vp.x; s > vra[0].y && s < vra[1].y) return true;
	}
	return false;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> calcPointToRectangle(const Point<T>& p, const Point<T>* const p_p) noexcept
requires std::floating_point<T>
{
	return p * (p_p[1] - p_p[0]) + p_p[0];
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> calcPointToRectangle(const Point<T>& p, const std::vector<Point<T>>& pv) noexcept
requires std::floating_point<T>
{
	return calcPointToRectangle(p, pv.data());
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> calcPointToRectangle(const Point<T>& p, const std::array<Point<T>, 2>& pa) noexcept
requires std::floating_point<T>
{
	return calcPointToRectangle(p, pa.data());
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline Point<T> calcPointFromRectangle(const Point<T>& p, const Point<T>* const p_p)
requires std::floating_point<T>
{
	constexpr T r = T(1.0E-8); // Range
	const Point<T> pp(p_p[1] - p_p[0]); // Position of p
	if (fabs(pp.x) > r && fabs(pp.y) > r) return (p - p_p[0]) / pp;
	return {T(0.0), T(0.0)}; // No area case
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline Point<T> calcPointFromRectangle(const Point<T>& p, const std::vector<Point<T>>& pv)
requires std::floating_point<T>
{
	return calcPointFromRectangle(p, pv.data());
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline Point<T> calcPointFromRectangle(const Point<T>& p, const std::array<Point<T>, 2>& pa)
requires std::floating_point<T>
{
	return calcPointFromRectangle(p, pa.data());
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
} //namespace ama
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#endif // AMA_RECTANGLE_H
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
