//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Point.h
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Copyright (c) 2023 Adrian Maurer. All rights reserved.
// Distributed under the MIT software license (http://www.opensource.org/licenses/mit-license.php).
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#ifndef AMA_POINT_H
#define AMA_POINT_H
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <cmath>
#include <concepts>
#include "Constant.h"
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace ama {
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Point<T>
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
class Point
{
// ELEMENT DATA
public:
	T x, y;

// CONSTRUCTION / DESTRUCTION / ASSIGNMENT
public:
	constexpr Point() noexcept : x(T(0)), y(T(0)) {}
	constexpr Point(const T v) noexcept : x(v), y(v) {}
	constexpr Point(const T vx, const T vy) noexcept : x(vx), y(vy) {}

// ELEMENT FUNCTIONS
public:
	constexpr Point& operator+=(const Point<T>& p) noexcept {x += p.x, y += p.y; return *this;}
	constexpr Point& operator-=(const Point<T>& p) noexcept {x -= p.x, y -= p.y; return *this;}
	constexpr Point& operator*=(const Point<T>& p) noexcept {x *= p.x, y *= p.y; return *this;}
	constexpr Point& operator/=(const Point<T>& p) noexcept {x /= p.x, y /= p.y; return *this;}
	constexpr Point& operator+=(const T v) noexcept {x += v, y += v; return *this;}
	constexpr Point& operator-=(const T v) noexcept {x -= v, y -= v; return *this;}
	constexpr Point& operator*=(const T v) noexcept {x *= v, y *= v; return *this;}
	constexpr Point& operator/=(const T v) noexcept {x /= v, y /= v; return *this;}
	constexpr Point& translateX(const T tx) noexcept {x += tx; return *this;}
	constexpr Point& translateY(const T ty) noexcept {y += ty; return *this;}
	constexpr Point& translateXY(const Point<T>& p) {return operator+=(p);}
	constexpr Point& scaleX(const T sx) noexcept {x *= sx; return *this;}
	constexpr Point& scaleY(const T sy) noexcept {y *= sy; return *this;}
	constexpr Point& scaleXY(const Point<T>& p) noexcept {return operator*=(p);}
	Point& rotate(const T a) noexcept requires std::floating_point<T>;
	constexpr Point& shearX(const T sx) noexcept {x += y * sx; return *this;}
	constexpr Point& shearY(const T sy) noexcept {y += x * sy; return *this;}
};
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Point<T> - ELEMENT FUNCTIONS
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline Point<T>& Point<T>::rotate(const T a) noexcept
requires std::floating_point<T>
{
	const T ca = cos(a);
	const T sa = sin(a);
	const T tx = x;
	x = tx * ca - y * sa;
	y = tx * sa + y * ca;
	return *this;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Point<T> - GOBAL FUNCTIONS
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator+(Point<T> p) noexcept
{
	return p;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator-(Point<T> p) noexcept
{
	return {-p.x, -p.y};
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator+(Point<T> p1, const Point<T>& p2) noexcept
{
	return p1 += p2;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator-(Point<T> p1, const Point<T>& p2) noexcept
{
	return p1 -= p2;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator*(Point<T> p1, const Point<T>& p2) noexcept
{
	return p1 *= p2;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator/(Point<T> p1, const Point<T>& p2) noexcept
{
	return p1 /= p2;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator+(Point<T> p, const T v) noexcept
{
	return p += v;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator+(const T v, Point<T> p) noexcept
{
	return p += v;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator-(Point<T> p, const T v) noexcept
{
	return p -= v;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator-(const T v, const Point<T>& p) noexcept
{
	return {v - p.x, v - p.y};
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator*(Point<T> p, const T v) noexcept
{
	return p *= v;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator*(const T v, Point<T> p) noexcept
{
	return p *= v;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator/(Point<T> p, const T v) noexcept
{
	return p /= v;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> operator/(const T v, const Point<T>& p) noexcept
{
	return {v / p.x, v / p.y};
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> translateX(Point<T> p, const T tx) noexcept
{
	return p.translateX(tx);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> translateY(Point<T> p, const T ty) noexcept
{
	return p.translateY(ty);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> translateXY(Point<T> p, const Point<T>& tp) noexcept
{
	return p.translateXY(tp);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> scaleX(Point<T> p, const T sx) noexcept
{
	return p.scaleX(sx);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> scaleY(Point<T> p, const T sy) noexcept
{
	return p.scaleY(sy);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> scaleXY(Point<T> p, const Point<T>& sp) noexcept
{
	return p.scaleXY(sp);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> rotate(Point<T> p, const T ra) noexcept
{
	return p.rotate(ra);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> shearX(Point<T> p, const T sx) noexcept
{
	return p.shearX(sx);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
constexpr Point<T> shearY(Point<T> p, const T sy) noexcept
{
	return p.shearY(sy);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline T calcLength(const Point<T>& p) noexcept
requires std::floating_point<T>
{
	return sqrt(p.x * p.x + p.y * p.y);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline T calcAngle(const Point<T>& p) noexcept
requires std::floating_point<T>
{
	if (p.x == T(0.0))
	{
		if (p.y == T(0.0)) return T(0.0);
		else if (p.y < T(0.0)) return T(rad_270);
		else if (p.y > T(0.0)) return T(rad_090);
	}
	else
	{
		const T a = atan(p.y / p.x);
		if (p.x < T(0.0)) return a + T(rad_180);
		else if (p.x > T(0.0)) return p.y < T(0.0) ? a + T(rad_360) : a;
	}
	return T(0.0);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
} //namespace ama
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#endif // AMA_POINT_H
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
